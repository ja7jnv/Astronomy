# Larkの解析機能
* 解析木の解説
https://share.google/aimode/Af135Oo3VbdpfO9tI
print(tree.pretty()) の活用：
Interpreter が見ている「地図」をテキスト形式で綺麗に表示してくれます。どのノードがどの階層にあるか一目瞭然になります。

visit_children(tree) の動き：
yaccのように全要素を順番に処理したいだけなら、自分で children[0] ... と書かずに self.visit_children(tree) と書くだけで、子ノード全員の実行結果をリストで取得できます。

トークンの value と type：
tree.children[n] が Token だった場合、それは終端記号（文字列）です。その中身を str() で取るか、.value で取るかを意識すると、型エラーを減らせます。

# cmdクラスの活用
* ヘルプ機能
* 補完機能
https://share.google/aimode/ONVoj3Q0iqdCejX3M

実装に役立つ構成要素
１．Completer のカスタマイズ:
prompt_toolkit.completion.Completer クラスを継承して、
get_completions メソッド内で lark.InteractiveParser.accepts() を
呼び出すようにすると、文法に基づいた正確な自動補完が実現できます。

２．動的なプロンプトの変更:
入力待ちの状態で、次に何が必要かに応じてプロンプト（>>> や ... 緯度 = ）を
動的に書き換えることができます。

３．複数行入力（Multiline）モード:
DSLで定義したコマンドが完結するまで入力を続けさせたい場合、
PromptSession の multiline オプションと Validator を組み合わせると、
構文的に正しい状態になるまで Enter を押しても改行として扱い、
パース可能になったら実行する、という挙動も作れます。

４．次に調べるべきクラス名
prompt_toolkit.shortcuts.PromptSession: 基本的な対話セッション。
prompt_toolkit.lexers.Lexer: 入力中の文字にシンタックスハイライト（色付け）を適用する際に使用。
prompt_toolkit.validation.Validator: パースエラーがある間は入力を確定させない（継続させる）ロジックに使用。

# オブジェクトの属性を変数化
Pythonの標準関数である getattr() を使うことで、
ephem.Mars のようなクラス名を変数で指定し、動的に呼び出すことが可能です。 
* ephem.Mars の Mars の部分を変数に置き換える
https://share.google/aimode/XN1tjWDfrKBNKjTqM
https://zenn.dev/giba/articles/a4e5c2bc9ca6f1

* 実装方法
変数に惑星名の文字列（例: 'Mars', 'Jupiter'）を代入し、
それを getattr(ephem, 変数名)() として呼び出します。 
python
import ephem

* コード例
planet_name = 'Mars' #惑星名を変数に格納
planet = getattr(ephem, planet_name)()  # getattrを使って動的にクラスを取得し、インスタンス化する
planet.compute('2026/1/1')  # 通常通り使用可能
print(f"{planet.name} の赤経: {planet.ra}, 赤緯: {planet.dec}")

# Class名を文字列などで動的に指定してクラスを生成・使用するには
type()関数、globals()、またはgetattr()を使用します。
特にtype(name, bases, attrs)は、クラス名、継承元、属性を引数としてクラスを即座に
定義できるため、動的クラス生成に有用です。

* コード例
class_name = "DynamicClass"
//# type(クラス名, 継承クラス(タプル), 属性・メソッドの辞書)
MyClass = type(class_name, (object,), {
    "greet": lambda self: "Hello from " + class_name
})

instance = MyClass()
print(instance.greet())  # 出力: Hello from DynamicClass

* globals()による文字列からのクラス取得
定義済みのクラス名（文字列）に対応するクラスをグローバルスコープから取得します。
python
class TargetClass:
    def method(self):
        return "TargetClassのメソッド"

class_name_str = "TargetClass"
//# クラス名を文字列で指定して取得
cls = globals()[class_name_str]
instance = cls()
print(instance.method())

# 動的関数コールの引数なしの場合 ephem.now(None) -> ephem.now()
引数 value が None の場合に引数なしで呼び出すには、
三項演算子 や 引数のアンパック（*args） を使うのがスマートです。

1. 三項演算子を使う方法（読みやすさ重視）
最もシンプルで直感的な書き方です。
python
func = getattr(ephem, attr)
target = func(value) if value is not None else func()
コードは注意してご使用ください。

2. 引数アンパック（*args）を使う方法（短く書きたい場合）
value が None でなければ要素1つのリスト、None なら空のリストを作成して展開します。
python
args = [value] if value is not None else []
target = getattr(ephem, attr)(*args)
コードは注意してご使用ください。

この書き方は、後から引数が増える可能性がある場合に柔軟に対応できるのがメリットです。

3. 関数を定義して共通化する
頻繁にこの処理を行う場合は、ユーティリティ関数を作るとコードがスッキリします。
python
def call_dynamic(obj, attr_name, val):
    func = getattr(obj, attr_name)
    return func(val) if val is not None else func()

target = call_dynamic(ephem, attr, value)
コードは注意してご使用ください。

PyEphem などのライブラリでは、引数の有無で挙動が変わるメソッドが多いため、
上記のような条件分岐はよく使われるパターンです。

# Larkで var.attr のようなdotアクセスを定義
PythonのLarkライブラリを使ってvar.attr（変数.属性）のような
ドット表記の属性アクセスを解析するには、
Larkの文法定義（Grammar）で階層的なルールを定義し、
Transformerを使用して解析ツリーを構造化されたPythonオブジェクトに変換します。

以下に、var.attr または var.attr.subattr を解析する具体的な実装例を示します。

* Lark文法とTransformerの実装
python
from lark import Lark, Transformer, v_args
//# 1. 文法定義 (var.attr, var.attr.attr...)
grammar = """
    ?start: expression

    ?expression: dot_access | CNAME

    //# 変数名 . 属性名
    dot_access: CNAME "." CNAME  -> get_attr
              | dot_access "." CNAME -> get_attr

    %import common.CNAME
    %import common.WS
    %ignore WS
"""

//# 2. Transformer定義（ツリーを解析してPythonオブジェクトにする）
class AttributeTransformer(Transformer):
    def get_attr(self, items):
        //# itemsは[object, attribute_name]のリスト
        obj, attr = items
        return f"{obj}.{attr}" //# ここでは文字列として結合していますが、
                               //# ASTノードを返すのが一般的です

//# 3. パーサーの初期化
parser = Lark(grammar, start='start', parser='lalr', transformer=AttributeTransformer())

//# 4. 実行
text = "user.address.zipcode"
result = parser.parse(text)
print(result) # 出力: user.address.zipcode

* 実装のポイント
** dot_access ルール:
CNAME "." CNAME（例: var.attr）を定義し、
さらに dot_access "." CNAME とすることで、
a.b.c のような連続した属性アクセス（連鎖）に対応しています。
** -> get_attr (エイリアス):
ルール名にエイリアスを付けることで、
Transformerで処理しやすくします。
** Transformer:
解析ツリーを下から上へ（bottom-up）処理し、
解析されたトークンをPythonの文字列、リスト、あるいはカスタムオブジェクトに変換します。 

* 応用：抽象構文木(AST)の作成
通常は文字列を返すのではなく、Transformerで以下のようなオブジェクトを返します。
python
class AttributeTransformer(Transformer):
    def get_attr(self, items):
        return {"type": "attribute_access", "object": items[0], "attr": items[1]}

この方法により、lark は var.attr を堅牢に解析し、
Pythonコードの静的解析やカスタムスクリプト言語のインタープリタ作成に利用できます。

https://share.google/aimode/j4OQ1jhXTPP1160r1
